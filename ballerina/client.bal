// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/data.jsondata;
import ballerina/http;
import ballerina/mime;

# APIs for sampling from and fine-tuning language models
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config =  {}, string serviceUrl = "https://api.openai.com/v1") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Creates a model response for the given chat conversation.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post chat/completions(CreateChatCompletionRequest payload, map<string|string[]> headers = {}) returns CreateChatCompletionResponse|error {
        string resourcePath = string `/chat/completions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Creates a completion for the provided prompt and parameters.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post completions(CreateCompletionRequest payload, map<string|string[]> headers = {}) returns CreateCompletionResponse|error {
        string resourcePath = string `/completions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Creates a new edit for the provided input, instruction, and parameters.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post edits(CreateEditRequest payload, map<string|string[]> headers = {}) returns CreateEditResponse|error {
        string resourcePath = string `/edits`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Creates an image given a prompt.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post images/generations(CreateImageRequest payload, map<string|string[]> headers = {}) returns ImagesResponse|error {
        string resourcePath = string `/images/generations`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Creates an edited or extended image given an original image and a prompt.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post images/edits(CreateImageEditRequest payload, map<string|string[]> headers = {}) returns ImagesResponse|error {
        string resourcePath = string `/images/edits`;
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Creates a variation of a given image.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post images/variations(CreateImageVariationRequest payload, map<string|string[]> headers = {}) returns ImagesResponse|error {
        string resourcePath = string `/images/variations`;
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Creates an embedding vector representing the input text.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post embeddings(CreateEmbeddingRequest payload, map<string|string[]> headers = {}) returns CreateEmbeddingResponse|error {
        string resourcePath = string `/embeddings`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Transcribes audio into the input language.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post audio/transcriptions(CreateTranscriptionRequest payload, map<string|string[]> headers = {}) returns CreateTranscriptionResponse|error {
        string resourcePath = string `/audio/transcriptions`;
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Translates audio into English.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post audio/translations(CreateTranslationRequest payload, map<string|string[]> headers = {}) returns CreateTranslationResponse|error {
        string resourcePath = string `/audio/translations`;
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Returns a list of files that belong to the user's organization.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get files(map<string|string[]> headers = {}) returns ListFilesResponse|error {
        string resourcePath = string `/files`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post files(CreateFileRequest payload, map<string|string[]> headers = {}) returns OpenAIFile|error {
        string resourcePath = string `/files`;
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Returns information about a specific file.
    #
    # + fileId - The ID of the file to use for this request
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get files/[string fileId](map<string|string[]> headers = {}) returns OpenAIFile|error {
        string resourcePath = string `/files/${getEncodedUri(fileId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a file.
    #
    # + fileId - The ID of the file to use for this request
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function delete files/[string fileId](map<string|string[]> headers = {}) returns DeleteFileResponse|error {
        string resourcePath = string `/files/${getEncodedUri(fileId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Returns the contents of the specified file
    #
    # + fileId - The ID of the file to use for this request
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get files/[string fileId]/content(map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/files/${getEncodedUri(fileId)}/content`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List your organization's fine-tuning jobs
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get fine\-tunes(map<string|string[]> headers = {}) returns ListFineTunesResponse|error {
        string resourcePath = string `/fine-tunes`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Creates a job that fine-tunes a specified model from a given dataset.
    # 
    # Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.
    # 
    # [Learn more about Fine-tuning](/docs/guides/fine-tuning)
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post fine\-tunes(CreateFineTuneRequest payload, map<string|string[]> headers = {}) returns FineTune|error {
        string resourcePath = string `/fine-tunes`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Gets info about the fine-tune job.
    # 
    # [Learn more about Fine-tuning](/docs/guides/fine-tuning)
    #
    # + fineTuneId - The ID of the fine-tune job
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get fine\-tunes/[string fineTuneId](map<string|string[]> headers = {}) returns FineTune|error {
        string resourcePath = string `/fine-tunes/${getEncodedUri(fineTuneId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Immediately cancel a fine-tune job.
    #
    # + fineTuneId - The ID of the fine-tune job to cancel
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post fine\-tunes/[string fineTuneId]/cancel(map<string|string[]> headers = {}) returns FineTune|error {
        string resourcePath = string `/fine-tunes/${getEncodedUri(fineTuneId)}/cancel`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get fine-grained status updates for a fine-tune job.
    #
    # + fineTuneId - The ID of the fine-tune job to get events for
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get fine\-tunes/[string fineTuneId]/events(map<string|string[]> headers = {}, *ListFineTuneEventsQueries queries) returns ListFineTuneEventsResponse|error {
        string resourcePath = string `/fine-tunes/${getEncodedUri(fineTuneId)}/events`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Lists the currently available models, and provides basic information about each one such as the owner and availability.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get models(map<string|string[]> headers = {}) returns ListModelsResponse|error {
        string resourcePath = string `/models`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
    #
    # + model - The ID of the model to use for this request
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get models/[string model](map<string|string[]> headers = {}) returns Model|error {
        string resourcePath = string `/models/${getEncodedUri(model)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a fine-tuned model. You must have the Owner role in your organization.
    #
    # + model - The model to delete
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function delete models/[string model](map<string|string[]> headers = {}) returns DeleteModelResponse|error {
        string resourcePath = string `/models/${getEncodedUri(model)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Classifies if text violates OpenAI's Content Policy
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post moderations(CreateModerationRequest payload, map<string|string[]> headers = {}) returns CreateModerationResponse|error {
        string resourcePath = string `/moderations`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }
}
